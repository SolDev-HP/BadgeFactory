{"language":"Solidity","sources":{"RewardPoints.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\nimport \"./CampaignBase.sol\";\r\n\r\n// RewardPoints contract\r\n// Responsible for everything related to reward points - distribution/claims\r\n/// @title RewardPoints smart contract\r\n/// @author SolDev-HP\r\n/// @notice This contract is responsible for handling reward points redeem/claim and user subscription\r\n/// @dev This is a campaign, it will be deployed by campaigndeployer and\r\n/// the owner will be assigned to msg.sender\r\n\r\n/// This is going to get more customized, once I implement the base Campaign contract,\r\n///    - There are some basic functionality shared by all Campaigns (ICampaign.sol interface)\r\n///    - Some common state variables like owner_Console, campaign_details_hash\r\n///    -- change in campaign_details_hash will move to another var,\r\n/// _cust_id_to_cust_address is internal custid related to this campaign only,\r\n/// _is_cust_subscribed - will move to parent contract, it's crucial component for any campaign to make sure -\r\n///    customer is subscribed because there are certain functions that can be done by customers and for that -\r\n///    we need to have this modifier for basic check\r\ncontract RewardPoints is CampaignBase {\r\n    // ------------- State Vars\r\n    uint256 private _total_points;\r\n    uint256 private _total_customers_counter;\r\n\r\n    mapping(uint256 => address) private _cust_id_to_cust_address;\r\n    mapping(address => bool) private _is_cust_subscribed;\r\n    mapping(address => uint256) private _points_of_customer;\r\n\r\n    // Probably need events if we need these data for analytics\r\n    event RewardPointsRedeemed(address _customer, uint256 _points);\r\n    event RewardPointsGained(address _customer, uint256 _points);\r\n\r\n    // ------------- Modifier\r\n\r\n    // Testing only\r\n    modifier onlySelf(address customer) {\r\n        bool is_cust = ILoyaltyConsole(campaign_owner).is_customer(customer);\r\n        require(is_cust, \"UnSubbed\");\r\n        require(msg.sender == customer, \"OnlyYours!\");\r\n        _;\r\n    }\r\n\r\n    // Reward points can be\r\n    // - Lifetype validity, no expiry, can be used anytime\r\n    // - limited time validity, expires\r\n    // - limited accessibility - no transfers\r\n\r\n    // Owner of this campaign can\r\n    //      (for future, this can may be use signed permit)\r\n    // distribute reward points\r\n    // change reward points type\r\n    // deploy mini campaigns involving reward points main campaign\r\n\r\n    // Customers can\r\n    // redeem reward points\r\n    // transfer reward points to friends, family\r\n    constructor() {\r\n        //campaign_owner_console = camp_owner;\r\n        // This will be cloned onto loyaltyConsole whenever required\r\n        // Deploy once but cloned as many times as required\r\n    }\r\n\r\n    // A simple public function to get details (metadata) of this campaign\r\n    function get_campaign_details()\r\n        public\r\n        view\r\n        returns (bytes memory details_hash)\r\n    {\r\n        details_hash = campaign_details_hash;\r\n    }\r\n\r\n    // Something to override for basic checks\r\n    function get_campaign_type_and_details()\r\n        public\r\n        view\r\n        override\r\n        returns (bytes memory campaign_hash, bytes memory campaign_type)\r\n    {\r\n        campaign_hash = campaign_details_hash;\r\n        campaign_type = \"Reward Points / (maybe) Air Miles\";\r\n    }\r\n\r\n    // This can be done by customer themselves, but for now we keep\r\n    // access control with console so everything can be done from\r\n    // console --\r\n    // @todo - customer can be wallet address or phone number or email address or a QR code (wallet mixed with coupon/badge)\r\n    // Instead of storing customer details on here, store it on local ipfs node\r\n    // This hash can be used as a customer identifier.\r\n    // This is hash similar to Campaign struct hash, but the difference is that it's not public\r\n    // This can be handled by business/brands on their own or can use default provided by badgefactory backend\r\n    // For CampaignDetails struct, (future: Badges images/gifs(media), tickets media, Codes media) can be -\r\n    // on public ipfs, they are for UI and doesn't contain actual operational data\r\n    function subscribe_customer(address customer) external onlyConsole {\r\n        require(\r\n            ILoyaltyConsole(campaign_owner).is_customer(customer),\r\n            \"NotSubbedonConsole!\"\r\n        );\r\n        // If I keep total_cust_counter for reference with loyalty console data,\r\n        // this contract doesn't need _is_cust_subscribed anymore, just here, everywhere -\r\n        // else it's already replaced by a call to LoyaltyConsole.is_customer() function\r\n        require(!_is_cust_subscribed[customer], \"AlreadySubbed!\");\r\n        // Assign custid->address\r\n        _cust_id_to_cust_address[_total_customers_counter] = customer;\r\n        // Increase total number\r\n        _total_customers_counter += 1;\r\n        // Customer has subscribed\r\n        _is_cust_subscribed[customer] = true;\r\n    }\r\n\r\n    // Need these two for later customizations for customer data,\r\n    // currently we only use wallet address for POC.\r\n    // data hash for customer data can only work if we store that data securely, not on ipfs.\r\n    // So internal ipfs here will be considered ipfs controlled by loyaltyconsole deployer entities.\r\n    // but campaign data can be actively available, so public writtable ipfs node can work.\r\n\r\n    // function subscribe_customer(bytes customer_data_hash) external onlyConsole {}\r\n    // function unsubscribe_customer(bytes customer_data_hash) external onlyConsole {}\r\n    // function update_customer(bytes customer_data_hash) external onlyConsole {}\r\n    // function update_profile(bytes customer_data_extended) external onlySelf {//cust only}\r\n\r\n    function total_subscribers()\r\n        external\r\n        view\r\n        onlyConsole\r\n        returns (uint256 no_of_subs)\r\n    {\r\n        no_of_subs = _total_customers_counter;\r\n    }\r\n\r\n    // OnlyEntity can access any subscriber's points\r\n    function check_subscriber_points(\r\n        address customer\r\n    ) external view onlyConsole returns (uint256 total_points) {\r\n        return _points_of_customer[customer];\r\n    }\r\n\r\n    // Subscriber can only see their own points\r\n    function get_self_points(\r\n        address customer\r\n    ) external view onlySelf(customer) returns (uint256 total_points) {\r\n        return _points_of_customer[customer];\r\n    }\r\n\r\n    // Tester, remove in prod\r\n    function check_owner() external view returns (address) {\r\n        return campaign_owner;\r\n    }\r\n\r\n    function reward_points(\r\n        address customer,\r\n        uint256 _additional_points\r\n    ) external onlyConsole {\r\n        // Is this customer subscribed?\r\n        //require(_is_cust_subscribed[customer], \"NotSubbed\");\r\n        bool is_cust = ILoyaltyConsole(campaign_owner).is_customer(customer);\r\n        require(is_cust, \"NotSubbed\");\r\n        // Reward customer with points\r\n        // Customer identifier required\r\n        unchecked {\r\n            _points_of_customer[customer] += _additional_points;\r\n            // Increase total circulating points count\r\n            _total_points += _additional_points;\r\n        }\r\n        emit RewardPointsGained(customer, _additional_points);\r\n    }\r\n\r\n    function redeem_points(\r\n        address customer,\r\n        uint256 _redeemed_points\r\n    ) external onlyConsole {\r\n        // Customer subscribed?\r\n        bool is_cust = ILoyaltyConsole(campaign_owner).is_customer(customer);\r\n        require(is_cust, \"NotSubbed\");\r\n        // Customer redeems the points\r\n        require(\r\n            _points_of_customer[customer] >= _redeemed_points,\r\n            \"NotEnoughPoints\"\r\n        );\r\n        require(_total_points >= _redeemed_points, \"CantHappen\");\r\n        unchecked {\r\n            // reduce customer's points, it can become 0\r\n            _points_of_customer[customer] -= _redeemed_points;\r\n            // reduce total as well, bugfix\r\n            _total_points -= _redeemed_points;\r\n        }\r\n        emit RewardPointsRedeemed(customer, _redeemed_points);\r\n    }\r\n}\r\n"},"CampaignBase.sol":{"content":"// SPDX-License-Identifier: SolDev-HP\r\npragma solidity 0.8.20;\r\nimport \"./interfaces/ICampaignBase.sol\";\r\nimport \"./interfaces/ILoyaltyConsole.sol\";\r\n\r\n// Other validations can be added such as _Campaign_details check before add\r\n// Address check before add - parameter in set_campaign_owner\r\n// Created at has no use for now, but I have plans.\r\n\r\ncontract CampaignBase is ICampaignBase {\r\n    // ------- State vars\r\n    // We need an owner and details-hash - common for all\r\n    address public campaign_owner;\r\n    bytes public campaign_details_hash;\r\n    uint public campaign_create_at;\r\n\r\n    event CampaignCreated(address _campaign_address);\r\n\r\n    constructor() {\r\n        // Not too serious use for now, if so, change block.timestamp to something else\r\n        campaign_create_at = block.timestamp;\r\n    }\r\n\r\n    // ------- Modifiers\r\n    modifier onlyConsole() {\r\n        require(msg.sender == campaign_owner, \"OnlyOwnerConsole\");\r\n        _;\r\n    }\r\n\r\n    function set_campaign_details(\r\n        bytes memory _campaign_details\r\n    ) external onlyConsole {\r\n        // Make sure only console can call - explain why @todo\r\n        // campaign_details_hash - contains CampaignData struct hash\r\n        campaign_details_hash = _campaign_details;\r\n    }\r\n\r\n    function set_campaign_owner(address _campaign_owner) external {\r\n        // I'll move to rolebased systems that are already established -\r\n        // like openzeppelin or solmate, once I make sure all campaign child contract -\r\n        // and their deployment sizes are within bounds after adding all -\r\n        // required functionalities to them. So till then, -\r\n        // we use a function that can - only once\r\n        require(campaign_owner == address(0x0), \"ShouldBeEmpty\");\r\n        campaign_owner = _campaign_owner;\r\n        emit CampaignCreated(address(this));\r\n    }\r\n\r\n    // Gets overridden by child campaign,\r\n    // that sets their own campaign_type return\r\n    function get_campaign_type_and_details()\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes memory campaign_hash, bytes memory campaign_type)\r\n    {\r\n        campaign_hash = campaign_details_hash;\r\n        campaign_type = \"Home\";\r\n    }\r\n}\r\n"},"interfaces/ILoyaltyConsole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// For BadgeFactory to use\r\ninterface ILoyaltyConsole {\r\n    function set_campaign_deployer(address) external;\r\n\r\n    function is_customer(address customer) external view returns (bool);\r\n}\r\n"},"interfaces/ICampaignBase.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// Campaign should have some basic functionalities\r\n// set_campaign_details_hash(bytes hash) -> none - possibly to update campaign details data with new hash\r\n// get_campaign_details_hash() -> bytes hash - for UI, simple hash can be translated into CampaignDetails struct with value\r\n// subscribe_customer(bytes cust_data_hash) -> none - subscribe customer with given customer data\r\n// get_number_of_subscribers() -> int - total number of subscribers in the campaign\r\n// function set_campaign_owner(address) external; - as we are using currently\r\n\r\n// update: 14/04\r\n// branch: feature_campaign_struct\r\n// Changes in ICampaignBased (named from ICampaign) as I will now consider this a base contract\r\n// Base campaign should be able to do following things\r\n//  Create a new campaign   (so it tracks total_campaign, )\r\n//  set campaign status (active, inactive, paused, discontinued, and more)\r\n//  Emit some basic events\r\n// Contains total_campaigns_count\r\n// Contains _console_that_owns_this_campaign address\r\n// Contains campaign_details_hash - and related functions\r\n// So naturally related modifiers will switch to here instead of child campaigns\r\n\r\ninterface ICampaignBase {\r\n    // Set campaign owner, campaign owner would be loyaltyconsole always\r\n    // but this happens inside campaign cloning and setup process\r\n    function set_campaign_owner(address) external;\r\n\r\n    // Campaign details comes in as an ipfs hash\r\n    function set_campaign_details(bytes memory) external;\r\n}\r\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}
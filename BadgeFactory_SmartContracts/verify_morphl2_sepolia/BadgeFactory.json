{"language":"Solidity","sources":{"BadgeFactory.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n// import \"./interfaces/IDeployer.sol\";\r\nimport \"./LoyaltyConsole.sol\";\r\nimport \"./interfaces/IDeployer.sol\";\r\nimport \"./interfaces/ILoyaltyConsole.sol\";\r\nimport \"./Deployer.sol\";\r\n\r\n// For debugging only\r\n// import \"hardhat/console.sol\";\r\n\r\n/// @title BadgeFactory Deployer smart contract\r\n/// @author SolDev-HP\r\n/// @notice This is the main BadgeFactory contract, that will be connected to frontend, -\r\n/// it is responsible for registering new users with their role \"Customer\" or \"Entity,\r\n/// and can also LoyaltyConsole constract (For Entities) -\r\n/// Customer (EOA address): A customer is anyone who is interested in using someone's loyalty management system\r\n/// Entity (EOA address): A brand, business, project, or anyone that wants to deploy their own loyalty management system\r\n/// LoyaltyConsole (contract): Your(Entity) own loyalty management system console contract that can be used by you or your Customers\r\n/// For example:\r\n/// LoyaltyConsole access can grant campaign_deploy rights to Entity,\r\n/// LoyaltyConsole access can grant registration, redeem, claim, transfer loyalty campaigns rights to Customer\r\n/// \tregistration: register_for_given_entitys_loyalty_system (System name?)\r\n/// \tredeem - depends on campaign contract (RewardPoints, Badges, Tickets, Codes) : CampaignContext\r\n/// \tclaim - depends on campaign contract\r\n/// \ttransfer - depends on campaign contract\r\n/// @dev Main deployer of BadgeFactory - Manager of sub deployments\r\n/// Allows deployment of\r\n/// 1. LoyaltyConsole\r\n/// Ability for brand/business to deploy their chosen campaign\r\ncontract BadgeFactory {\r\n    // ------------- State Vars\r\n    // BadgeFactory Owner - SolDev-HP\r\n    address private _factory_owner;\r\n    address private _deployer_address;\r\n    // List of all available LoyaltyConsoles addresses\r\n    // with their deployer? @todo: check\r\n    // Register: Entity or Customer\r\n    // (address => address[]) implies that we allow multiple consoles to be deployed\r\n    mapping(address => address[]) public _address_deployed_loyaltyConsoles_list;\r\n    // Call with array index till output received is address(0x0), so we don't need a total\r\n    //      call is going to happen offline only, so no need for now.\r\n\r\n    // Badgefactory registery, role assignment\r\n    // _has_registered can be checked easily with assigned role,\r\n    // role inquiry will happen anyway when we execute modifiers\r\n    mapping(address => bool) private _address_is_Entity;\r\n    mapping(address => bool) private _address_is_Customer;\r\n    //mapping(address => uint8) private _user_role;\r\n\r\n    // To keep track of campaign implementations to use\r\n    mapping(uint256 => address) private _campaign_type_to_implementation;\r\n\r\n    // Using events for mapping flow, may or may not use in prod\r\n    event ConsoleCreated(address _consoleAddr);\r\n    event DeployerAt(address _campDeployer);\r\n    // ------------- Modifiers\r\n    modifier onlyFactoryOwner() {\r\n        require(msg.sender == _factory_owner, \"HPOnly!\");\r\n        _;\r\n    }\r\n\r\n    // Registered users only modifier\r\n    modifier registeredUsersOnly() {\r\n        require(\r\n            _address_is_Entity[msg.sender] || _address_is_Customer[msg.sender],\r\n            \"RegisteredOnly!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // ------------- Constructor\r\n    constructor() {\r\n        _factory_owner = msg.sender;\r\n        // Setup deployer\r\n        address campdep = setup_deployer();\r\n        emit DeployerAt(campdep);\r\n    }\r\n\r\n    // ------------- Receive Function\r\n    receive() external payable {\r\n        // if anything we need here\r\n    }\r\n\r\n    // ------------- Fallback Function\r\n    fallback() external payable {\r\n        // if anything we need here\r\n    }\r\n\r\n    // ------------- External Function\r\n    // ------------- Public Functions\r\n\r\n    // Public functionality\r\n    function register(bool _as_entity) public {\r\n        // Register the person, assign role\r\n        // Role assign from frontend, expect role to be entity if _as_entity is set\r\n        if (_as_entity) {\r\n            // Register them as entity\r\n            // BadgeFactory can check msg.value to charge\r\n            // for the deployment of loyaltyconsole for themselves\r\n            // If badgefactory offers enough, this will be revisited\r\n            _address_is_Entity[msg.sender] = true;\r\n        } else {\r\n            _address_is_Customer[msg.sender] = true;\r\n        }\r\n    }\r\n\r\n    function check_user_role(address _user) public view returns (uint8 _role) {\r\n        _role = 0;\r\n        if (_address_is_Entity[_user]) {\r\n            _role = 1;\r\n        }\r\n        if (_address_is_Customer[_user]) {\r\n            _role = 2;\r\n        }\r\n    }\r\n\r\n    // Registered Users Only functionality\r\n    // Deploy a Loyalty Management system\r\n    // Deploys LoyaltyConsole.sol contract and returns the added it's deployed at\r\n    function deploy_console(\r\n        uint256[] memory support_these_types\r\n    ) public registeredUsersOnly returns (address _console_addr) {\r\n        LoyaltyConsole _console;\r\n        // supported campaign types and their implementations\r\n        address[] memory camp_impls = new address[](support_these_types.length);\r\n        // Make sure we have given campaign_type implementation ready\r\n        for (uint256 i = 0; i < support_these_types.length; i++) {\r\n            require(\r\n                _campaign_type_to_implementation[support_these_types[i]] !=\r\n                    address(0x0),\r\n                \"ImplNotPresent\"\r\n            );\r\n            camp_impls[i] = _campaign_type_to_implementation[\r\n                support_these_types[i]\r\n            ];\r\n        }\r\n        // Deploy Console\r\n        // Pass it along with support_these_type_ requested\r\n        _console = new LoyaltyConsole(\r\n            address(this),\r\n            support_these_types,\r\n            camp_impls\r\n        );\r\n        // Assert console address though, we need console to be deployed\r\n        _console_addr = address(_console);\r\n        assert(_console_addr != address(0));\r\n        emit ConsoleCreated(_console_addr);\r\n        // Setup deployer in loyaltyConsole\r\n        // Deployer will have better use in the future, for now, it's just a safeguard\r\n        ILoyaltyConsole(_console_addr).set_campaign_deployer(_deployer_address);\r\n        // Setup deployer to accept this console as accessor\r\n        IDeployer(_deployer_address).change_accessor(_console_addr, true);\r\n\r\n        // Update total consoles list for the sender\r\n        _address_deployed_loyaltyConsoles_list[msg.sender].push(_console_addr);\r\n    }\r\n\r\n    // Campaign implementation setup\r\n    function set_campaign_implementation(\r\n        uint256 campaign_type,\r\n        address implementation\r\n    ) public onlyFactoryOwner {\r\n        _campaign_type_to_implementation[campaign_type] = implementation;\r\n    }\r\n\r\n    // Check deployer address, only for owner\r\n    function get_deployer()\r\n        public\r\n        view\r\n        onlyFactoryOwner\r\n        returns (address deployer)\r\n    {\r\n        deployer = _deployer_address;\r\n    }\r\n\r\n    // ------------- Internal Functions\r\n    // Only factory owner related functions\r\n    // mainly to setup the deployer, deployer is a contract that takes bytecode and deploy it\r\n    function setup_deployer() internal returns (address deployerAddr) {\r\n        deployerAddr = address(new Deployer());\r\n        // Assert we placed our deployer onchain\r\n        assert(deployerAddr != address(0));\r\n        // Setup our deployer\r\n        _deployer_address = deployerAddr;\r\n    }\r\n    // ------------- Private Function\r\n}\r\n"},"Deployer.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n/// @title Campaign deployer that assists in deploying\r\n/// multiple, different campaigns tailored to deployer's need\r\n/// @author SolDev-HP\r\n/// @notice We have four supported campaign types\r\n/// 1. Reward points - RewardPoints.sol\r\n/// 2. Loyalty Badges - Badges.sol\r\n/// 3. Tickets - Tickets.sol - Time dependent entry pass\r\n/// 4. Discount/Coupon code - Codes.sol\r\n/// @dev Given campaign name, and the msg sender,\r\n/// create a campaign and assigns the owner of the campaign as tx.origin\r\ncontract Deployer {\r\n    // ------------- State variables\r\n    address private _factory; // Deployer handler - BadgeFactory\r\n    mapping(address => bool) private _is_accessor; // LoyaltyConsole is accessing this\r\n\r\n    // Events for flow check/tests, remove in prod if not required\r\n    event AccessorAdded(address _accessor);\r\n    event CampaignDeployed(address _campAddr);\r\n\r\n    // ------------- Modifiers\r\n    // we need owner modifier, easy check nothing fancy so no lib use for now\r\n    modifier onlyFactory() {\r\n        require(msg.sender == _factory, \"OnlyFactory!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyLoyaltyConsole() {\r\n        require(_is_accessor[msg.sender], \"OnlyLoyaltyConsole!\");\r\n        _;\r\n    }\r\n\r\n    // ------------- Constructor\r\n    constructor() {\r\n        // Set deployer to be msg.sender - not tx.origin\r\n        // It means, the deployerbadgefactory contract\r\n        _factory = msg.sender;\r\n    }\r\n\r\n    // immediate call after constructor from factory\r\n    function change_accessor(\r\n        address _console_addr,\r\n        bool _allow\r\n    ) external onlyFactory returns (bool) {\r\n        _is_accessor[_console_addr] = _allow;\r\n        emit AccessorAdded(_console_addr);\r\n        return true;\r\n    }\r\n\r\n    // ------------- Receive Function\r\n    // ------------- Fallback Function\r\n\r\n    // ------------- External Function\r\n\r\n    /// @notice Create a campaign, return address where campaign is active at\r\n    /// @dev extcodesize comments from docs present\r\n    /// @param _campaign_data bytes param with campaign code to deploy\r\n    /// @return campAddr returns address the campaign is active at\r\n    function deploy_campaign(\r\n        bytes memory _campaign_data\r\n    ) external onlyLoyaltyConsole returns (address campAddr) {\r\n        assembly {\r\n            // Create a campaign, return address where campaign is active at\r\n            campAddr := create(\r\n                0,\r\n                add(_campaign_data, 0x20),\r\n                mload(_campaign_data)\r\n            )\r\n            // MorphL2 docs: https://docs.morphl2.io/docs/build-on-morph/build-on-morph/difference-between-morph-and-ethereum/\r\n            // Storage proof extcodesize opcode verification\r\n            // Instead, we store the contract size in storage at contract creation.\r\n            if iszero(extcodesize(campAddr)) {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        emit CampaignDeployed(campAddr);\r\n    }\r\n\r\n    // ------------- Public Functions\r\n    // ------------- Internal Functions\r\n    // ------------- Private Function\r\n}\r\n"},"interfaces/ILoyaltyConsole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// For BadgeFactory to use\r\ninterface ILoyaltyConsole {\r\n    function set_campaign_deployer(address) external;\r\n\r\n    function is_customer(address customer) external view returns (bool);\r\n}\r\n"},"interfaces/IDeployer.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IDeployer {\r\n    // It has only one work, deploy any given deploycode data and return address\r\n    function deploy_campaign(bytes memory) external returns (address);\r\n\r\n    // factoryonly function\r\n    function change_accessor(address, bool) external returns (bool);\r\n}\r\n"},"LoyaltyConsole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./interfaces/IDeployer.sol\";\r\nimport \"./interfaces/ICampaignBase.sol\";\r\nimport \"./interfaces/IRewardPoints.sol\";\r\n\r\nimport \"./interfaces/IBadges.sol\";\r\n\r\n// import \"./interfaces/ITickets.sol\";\r\n// import \"./interfaces/ICodes.sol\";\r\n\r\n// Campaign types are:\r\n// 1 - Reward Points\r\n// 2 - Badges\r\n// 3 - Tickets\r\n// 4 - Codes\r\ncontract LoyaltyConsole {\r\n    // Total campaigns deployed vs total running\r\n    // Useful for UI interactions\r\n    // Keeping them all public can be useful in UI/UX\r\n    // These can be moved to private or offchain, we can keep track of each with event emitted\r\n    // @todo check if it actually saves gas and storage space\r\n    uint256 public total_campaigns;\r\n    // Only total, @todo add way to check support for given campaign type\r\n    uint256 public total_supported_campaigns;\r\n    // Home Address\r\n    address private _factory;\r\n    address private _campaigns_deployer;\r\n    uint256 private _total_customers;\r\n\r\n    // Role mapper\r\n    // @todo: verify msg.sender vs tx.origin\r\n    mapping(address => bool) public _is_address_Entity;\r\n    // This would change once we add Customer_data_hash, for now it'll work\r\n    mapping(address => bool) public _is_address_Customer;\r\n    // Supported campaigns - and where their clones are (Address)\r\n    mapping(address => bool) public is_address_Campaign;\r\n    enum Campaign_Types {\r\n        UNDEFINED, //0\r\n        REWARD_POINTS, //1\r\n        BADGES, //2\r\n        TICKETS, //3\r\n        CODES //4\r\n    }\r\n    Campaign_Types camp_type_choice;\r\n    mapping(uint256 => uint256) public campaign_type_to_deploy_count;\r\n    mapping(uint256 => address) private _campaign_type_to_implementation;\r\n\r\n    // LoyaltyConsole:\r\n    // Entity: deploy new campaigns, register new users, modify campaigns, remove campaigns\r\n    // Customer: participate or register with entity\r\n\r\n    // Entity can deploy same campaign multiple times\r\n    // record all deployments to keep track within this console\r\n    mapping(uint256 => address[]) public _campaign_type_to_list_of_deployed;\r\n\r\n    // Add customer subscription here, campaign interactions happen from\r\n    // console (for now) anyway\r\n    // This will later change to id => cust_data_hash\r\n    mapping(uint256 => address) private _cust_id_to_cust_address;\r\n\r\n    // ------------- Constructor\r\n    // Deploy with list of deployable + supported campaigns for this console\r\n    // i.e. customizable console\r\n    constructor(\r\n        address factory_address,\r\n        uint256[] memory supported_types,\r\n        address[] memory types_implementations\r\n    ) {\r\n        // Whoever originated the tx, not the creation happened by badgefactory\r\n        // because msg.sender will be badgefactory always\r\n        _factory = factory_address;\r\n        require(_factory == msg.sender, \"OnlyFactory!\"); // Interesting check, need to see if it works\r\n        // Msg.sender here will always be factory\r\n        // tx.origin should be business/brand that is interacting with BadgeFactory.sol\r\n        _is_address_Entity[tx.origin] = true;\r\n        for (uint256 i = 0; i < supported_types.length; i++) {\r\n            _campaign_type_to_implementation[\r\n                supported_types[i]\r\n            ] = types_implementations[i];\r\n            total_supported_campaigns += 1;\r\n        }\r\n    }\r\n\r\n    // ------------- Modifiers\r\n    // Next refactor: move to openzeppelin role management maybe?\r\n    // Initiators should be these roles\r\n    modifier roleEntity() {\r\n        require(_is_address_Entity[tx.origin], \"EntityOnly\");\r\n        _;\r\n    }\r\n    modifier roleCustomer() {\r\n        require(_is_address_Customer[tx.origin], \"CustOnly\");\r\n        _;\r\n    }\r\n    // Updater should be this role\r\n    modifier roleFactory() {\r\n        require(_factory == msg.sender, \"FactoryOnly!\");\r\n        _;\r\n    }\r\n    // And campaign backcalling to validate customer?\r\n    // One place I can think of is where we call onlySelf() with custoemr-\r\n    // address. So we callback to validate that address, and only child-\r\n    // campaigns can do that\r\n    modifier roleCampaign() {\r\n        require(is_address_Campaign[msg.sender], \"CampaignOnly!\");\r\n        _;\r\n    }\r\n\r\n    // -------------- External functions\r\n    function set_campaign_deployer(\r\n        address _deployer_addr\r\n    ) external roleFactory {\r\n        _campaigns_deployer = _deployer_addr;\r\n    }\r\n\r\n    // Subscribe customer for loyalty campaigns, this could easily\r\n    // allow console to deploy new campaigns considering existing subscribers\r\n    // and not subscribe everyone for every campaign deployed\r\n    // For now Entity manually subscribes customer with their customer_data (wallet address for now)\r\n    function subscribe_to_loyalty_system(\r\n        address customer_data\r\n    ) public roleEntity {\r\n        require(!_is_address_Customer[customer_data], \"AlreadySubbed\");\r\n        // cust_id is what total_customer is right now, so first cust starts at 0\r\n        _cust_id_to_cust_address[_total_customers] = customer_data;\r\n        // total customers have increased\r\n        _total_customers += 1;\r\n        // customer is now subscribed to use the loyalty system\r\n        _is_address_Customer[customer_data] = true;\r\n    }\r\n\r\n    // And later unsubscribe_from_loyalty_system()\r\n\r\n    // Check from campaign if current customer\r\n    function is_customer(\r\n        address customer\r\n    ) external view roleCampaign returns (bool) {\r\n        return _is_address_Customer[customer];\r\n    }\r\n\r\n    // Deploying campaigns through console\r\n    // I know it wont return anything, but currently declared\r\n    // return var is reused within the function, so I'm keeping it until next Refactor comes @todo\r\n\r\n    // pCampaign_details_hash[0] is always CampaignData struct\r\n    // pCampaign_details_hash[1...N] are badges/tickets/coupons depending on campaign type\r\n    function start_campaign(\r\n        uint256 p_campaign_type,\r\n        bytes[] memory p_campaign_details_hash\r\n    ) public roleEntity returns (address _campaign_addr) {\r\n        // Verify that we have atleast 1 hash with details\r\n        // dont matter if it's 0x0 but there has to be atleast one\r\n        require(p_campaign_details_hash.length > 0, \"Atleast1Hash\");\r\n        // Assumed\r\n        require((0 < p_campaign_type) && (p_campaign_type < 5), \"1to4Only!\");\r\n        // Deployer is needed but deployer doesn't do anything for now. if you run into this,\r\n        // unittests are failing\r\n        require(address(_campaigns_deployer) != address(0), \"DeployerNeeded!\");\r\n\r\n        // Do we have requested campaign implementation available?\r\n        require(\r\n            _campaign_type_to_implementation[p_campaign_type] != address(0x0),\r\n            \"CampNotSupported\"\r\n        );\r\n\r\n        // Clone required campaign type\r\n        _campaign_addr = Clones.clone(\r\n            _campaign_type_to_implementation[p_campaign_type]\r\n        );\r\n        // Validate campaign deployment\r\n        require(address(_campaign_addr) != address(0), \"FailedCampDeploy!\");\r\n        // Set self as campaign owner, campaign control is on console\r\n        ICampaignBase(_campaign_addr).set_campaign_owner(address(this));\r\n        //// one hash sets by default, this sets Campaignbase details_hash\r\n        ICampaignBase(_campaign_addr).set_campaign_details(\r\n            p_campaign_details_hash[0]\r\n        );\r\n        if (p_campaign_details_hash.length > 1) {\r\n            // we verified that hashs array contain atleast one element\r\n            // Set total_badges_types first\r\n            // Not checking campaign_type for now as the only other type is badges\r\n            // tickets and codes are still in skeleton stage, so this will change when\r\n            // those are implemented like rewardpoints and badges campaigns contract : @todo\r\n            IBadges(_campaign_addr).set_total_badges_types(\r\n                p_campaign_details_hash.length - 1 // As first hash is parent hash - CampaignData\r\n                // Second onwards are badges/or any other that require multiple file hashes\r\n            );\r\n            // Then setup all badges types with their corresponding details_hash in the list\r\n            IBadges(_campaign_addr).set_all_badges_details_hashes(\r\n                p_campaign_details_hash\r\n            );\r\n        }\r\n        // _campaign_id for RewardPoints(1), Badges(2), Tickets(3), Codes(4)\r\n        // Probably needs more data along with each type, changes as we go\r\n        // Set campaign details hash, update related campaign counter\r\n        campaign_type_to_deploy_count[p_campaign_type] += 1;\r\n        // Increase total\r\n        total_campaigns += 1;\r\n        // Add to list of deployed\r\n        _campaign_type_to_list_of_deployed[p_campaign_type].push(\r\n            address(_campaign_addr)\r\n        );\r\n        // the address is now a campaign\r\n        is_address_Campaign[_campaign_addr] = true;\r\n    }\r\n\r\n    // Coming from BadgeFactory.sol - keep if needed\r\n    // Length of Campaigns returned from the mapping can be used to check total\r\n    // BadgeFactory Users\r\n    // struct Campaigns {\r\n    //     uint256 _campaign_id;\r\n    //     address _campaign_deployed_at;\r\n    //     // A way to identify campaign type (points, badges, tickets etc)\r\n    // }\r\n    // mapping(address => Campaigns[]) public campaign_deployers;\r\n\r\n    // Manually end any running campaign\r\n    // Implement function end_campaign(campaign_id) - set active false\r\n    // Implement auto end_campaign() - based on timestamp end_campaign - should update to active false (how?)\r\n\r\n    function interact_rewardpoints(\r\n        address customer,\r\n        uint points,\r\n        uint256 campaign_type,\r\n        bool _is_allocation\r\n    ) public roleEntity {\r\n        // Fidn last deployed reward points campaign\r\n        // Make sure we have atleast 1 reward points campaign deployed\r\n        require(\r\n            _campaign_type_to_list_of_deployed[campaign_type][0] !=\r\n                address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n        // Get the latest deployed rewardpoints campaign\r\n        address campAddr = _campaign_type_to_list_of_deployed[campaign_type][\r\n            campaign_type_to_deploy_count[campaign_type] - 1\r\n        ];\r\n        // If no points interaction (points are 0), subscribe\r\n        if (points == 0) {\r\n            // If we add a custoemr into reward points, add into loyaltyconsole\r\n            // Subscribe to loyalty system as well, if not already\r\n            if (!_is_address_Customer[customer]) {\r\n                subscribe_to_loyalty_system(customer);\r\n                // This will change in later versions\r\n                _is_address_Customer[customer] = true;\r\n            }\r\n            // This way, we allow customer to choose if they'd want to\r\n            // participate in any given loyalty campaign. By default, they\r\n            // are included, but they can interct with campaign and unsubscribe\r\n            IRewardPoints(campAddr).subscribe_customer(customer);\r\n        } else {\r\n            // if points are nonzero, it's an reward/redeem - reward_points\r\n            if (_is_allocation) {\r\n                IRewardPoints(campAddr).reward_points(customer, points);\r\n            } else {\r\n                IRewardPoints(campAddr).redeem_points(customer, points);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Now we have following functionality in badges\r\n\r\n    function interact_badges(\r\n        address customer,\r\n        uint256 _p_action,\r\n        uint256 _p_awarded_badge_type, // can be 0 for other actions\r\n        bytes[] memory _badges_hashes // along with updated campaigndetails struct too at 0 index\r\n    ) public roleEntity {\r\n        // So for badges, we can have following interactions:\r\n        // Subscribe(1): customer subscribe to deployed badges campaign\r\n        // Set_Total_types_of_Badges(2): set total types of badges(uint256 x)\r\n        // set_all_badges_details(3):\r\n        // award_badge_to_customer(4):\r\n        // Entity creates badges campaign\r\n        // Is customer registered\r\n        if (_p_action == 1) {\r\n            subscribe_to_loyalty_system(customer);\r\n            return;\r\n        }\r\n        // Make sure we have the campaign deployed\r\n        // uint256 campaign_type = uint(Campaign_Types.BADGES);\r\n        require(\r\n            _campaign_type_to_list_of_deployed[2][\r\n                campaign_type_to_deploy_count[2] - 1\r\n            ] != address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n\r\n        // Get the campaign deployment address\r\n        // Get the latest deployed rewardpoints campaign\r\n        address campAddr = _campaign_type_to_list_of_deployed[2][\r\n            // make sure to grab the latest badges deployed\r\n            campaign_type_to_deploy_count[2] - 1\r\n        ];\r\n\r\n        if (_p_action == 3) {\r\n            IBadges(campAddr).set_all_badges_details_hashes(_badges_hashes);\r\n            return;\r\n        }\r\n\r\n        if (_p_action == 4) {\r\n            require(_p_awarded_badge_type != 0, \"TypeStartsAt1\");\r\n            IBadges(campAddr).award_badge(customer, _p_awarded_badge_type);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Badges view related functionalities can be grouped here\r\n    // For now we have total_held_by_customer\r\n    function view_badges(\r\n        address customer\r\n    ) public view roleEntity returns (uint256) {\r\n        // need to make sure campaign(badges) is deployed\r\n        uint256 campaign_type = uint(Campaign_Types.BADGES);\r\n        require(\r\n            _campaign_type_to_list_of_deployed[campaign_type][0] !=\r\n                address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n\r\n        // Get campaign address\r\n        address campAddr = _campaign_type_to_list_of_deployed[campaign_type][\r\n            // make sure to grab the latest badges deployed\r\n            campaign_type_to_deploy_count[campaign_type] - 1\r\n        ];\r\n\r\n        // This will change later, right now I'm concerned with total held\r\n        return IBadges(campAddr).total_customer_held_badges(customer);\r\n    }\r\n\r\n    function interact_tickets() public roleEntity {}\r\n\r\n    function interact_codes() public roleEntity {}\r\n}\r\n"},"interfaces/IBadges.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IBadges {\r\n    // Customer subscription\r\n    function subscribe_customer(address) external;\r\n\r\n    // function get owner\r\n    function campaign_owner() external returns (address);\r\n\r\n    // Badges specific functions\r\n    // set multiple badges details hashes\r\n    // These are implemented as consoleOnly() callable functions\r\n    function set_total_badges_types(uint256) external;\r\n\r\n    function set_all_badges_details_hashes(bytes[] memory) external;\r\n\r\n    function get_badge_type_details_hash(\r\n        uint256\r\n    ) external view returns (bytes memory);\r\n\r\n    // Badges interactions, award customer a badge, check if customer -\r\n    // has given badge, check total customer held badges\r\n    function award_badge(address, uint256) external;\r\n\r\n    function check_customer_badge(\r\n        uint256,\r\n        address\r\n    ) external view returns (bool);\r\n\r\n    function total_customer_held_badges(\r\n        address\r\n    ) external view returns (uint256);\r\n}\r\n"},"interfaces/IRewardPoints.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IRewardPoints {\r\n    // Customer subscription\r\n    function subscribe_customer(address) external;\r\n\r\n    // Reward Points Interactions\r\n    function reward_points(address, uint256) external;\r\n\r\n    function redeem_points(address, uint256) external;\r\n}\r\n"},"interfaces/ICampaignBase.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// Campaign should have some basic functionalities\r\n// set_campaign_details_hash(bytes hash) -> none - possibly to update campaign details data with new hash\r\n// get_campaign_details_hash() -> bytes hash - for UI, simple hash can be translated into CampaignDetails struct with value\r\n// subscribe_customer(bytes cust_data_hash) -> none - subscribe customer with given customer data\r\n// get_number_of_subscribers() -> int - total number of subscribers in the campaign\r\n// function set_campaign_owner(address) external; - as we are using currently\r\n\r\n// update: 14/04\r\n// branch: feature_campaign_struct\r\n// Changes in ICampaignBased (named from ICampaign) as I will now consider this a base contract\r\n// Base campaign should be able to do following things\r\n//  Create a new campaign   (so it tracks total_campaign, )\r\n//  set campaign status (active, inactive, paused, discontinued, and more)\r\n//  Emit some basic events\r\n// Contains total_campaigns_count\r\n// Contains _console_that_owns_this_campaign address\r\n// Contains campaign_details_hash - and related functions\r\n// So naturally related modifiers will switch to here instead of child campaigns\r\n\r\ninterface ICampaignBase {\r\n    // Set campaign owner, campaign owner would be loyaltyconsole always\r\n    // but this happens inside campaign cloning and setup process\r\n    function set_campaign_owner(address) external;\r\n\r\n    // Campaign details comes in as an ipfs hash\r\n    function set_campaign_details(bytes memory) external;\r\n}\r\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}
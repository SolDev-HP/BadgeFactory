{"language":"Solidity","sources":{"Badges.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\nimport \"./CampaignBase.sol\";\r\nimport \"./interfaces/ILoyaltyConsole.sol\";\r\n\r\n// LoyaltyBadges contract -> renamed to Badges, avoids confusion with LoyaltyConsole\r\n// Everything related to loyalty badges - owner, exchange, review\r\n// What is the basic functionality of Loyalty Badges\r\n// Let's assume that a business wants to distribute loyalty badges to their loyalest customers,\r\n// who can use this badge to gain X% discount on the purchase - validity is limited by start time and -\r\n// end time of the badge_validity_period. These can be super rare like a lifetime 5% off badge, or may -\r\n// be businesses/brands can assign this badge as honor among their customers, or there are other use cases -\r\n// some known and some are yet to be tested.\r\n\r\ncontract Badges is CampaignBase {\r\n    // ------------- State Vars\r\n    uint256 public total_types_of_badges;\r\n    uint256 public total_badges_circulating;\r\n    uint256 private _total_customer_count;\r\n\r\n    // Customer if specifically subscribed for this campaign only\r\n    mapping(address => bool) private _cust_address_to_isSubscribed;\r\n\r\n    // Badges details, how many customer holds, which badges customer holds\r\n    mapping(address => uint256) private _cust_address_to_total_held_badges;\r\n    mapping(address => uint256[]) private _cust_add_to_held_badges_list;\r\n    mapping(uint256 => bytes) private _badge_type_to_badge_details_hash;\r\n\r\n    // Badgetype -> visibility (for all customers) - So by default visibility is public\r\n    // badgetype starts at 1\r\n    // 0 is for campaign_details_hash in parent\r\n    mapping(uint256 => bool) private _badge_type_to_is_privately_visible_only;\r\n\r\n    // ------------- Modifier\r\n    // we already have onlyConsole() available,\r\n    // Badges can be\r\n    // - Lifetype validity, no expiry, can be used anytime\r\n    // - limited time validity, expires\r\n    // - limited accessibility - no transfers\r\n\r\n    // Owner of this campaign can\r\n    // distribute badges to customers\r\n    // change and customize badge and its features/utility\r\n\r\n    // Customers can\r\n    // Claim their badges\r\n    // transfer badges to friends, family\r\n    constructor() {\r\n        // campaign_owner = camp_owner;\r\n        // We do this separately after construction happens\r\n    }\r\n\r\n    // Loyalty Badges specific - for testing\r\n    function get_campaign_type_and_details()\r\n        public\r\n        view\r\n        override\r\n        returns (bytes memory camp_details_hash, bytes memory campaign_type)\r\n    {\r\n        // campaign_details_hash is set at construction time\r\n        camp_details_hash = campaign_details_hash;\r\n        campaign_type = \"Loyalty Badges\";\r\n    }\r\n\r\n    //// Set total types of badges, this can be updated by onlyConsole\r\n    //// may emit an event for badges_types_updates or something\r\n    function set_total_badges_types(uint256 _total_types) external onlyConsole {\r\n        // This should happen once at the beggning when campaign deploy\r\n        // happens\r\n        total_types_of_badges = _total_types;\r\n    }\r\n\r\n    //// Console initiated Badges with N types, allow them to set hashes for all\r\n    //// Has to supply hash_list of length of total supported badge types\r\n    function set_all_badges_details_hashes(\r\n        bytes[] memory _p_all_hashes_list // list has to be atleast 1,\r\n    ) public onlyConsole {\r\n        // Has to make sure, total_badges_types == length of p_hashes_list\r\n        require(total_types_of_badges > 0, \"0BadgeTypesSet\");\r\n        require(\r\n            _p_all_hashes_list.length - 1 == total_types_of_badges, // We're sending hashes[1...onwards]\r\n            \"MoreHashesThanSupported\"\r\n        );\r\n        // If title BadgeDetails hasn't been set in super()\r\n        // This will be\r\n\r\n        if (campaign_details_hash.length == 0) {\r\n            campaign_details_hash = _p_all_hashes_list[0];\r\n        }\r\n        // Set all badges hashes details\r\n        // _badge_type_to_badge_details_hash(uint -> bytes)\r\n        // Supports type 1,2,3 and has set hash details for only 1 -\r\n        // 2 and 3 can be empty (set 0x0 in list) and that's okay,\r\n        // they can recall this to update hash with the new one\r\n        for (uint i = 1; i <= total_types_of_badges; ++i) {\r\n            // Don;t clean up, update the necessary one only\r\n            if (_p_all_hashes_list[i].length == 0) {\r\n                continue;\r\n                // Don't update currently set detail hash -\r\n                // if zero keep, if nonzero - don't update\r\n            }\r\n            // Non zero hash, update current hash associated with hashtype\r\n            // hashtype is p_all_hashes_list indirect index\r\n            // badgetype starts at 1 - 0 is always parent campaignHash\r\n            // 1 type is second badge and so on...\r\n            _badge_type_to_badge_details_hash[i] = _p_all_hashes_list[i];\r\n        }\r\n    }\r\n\r\n    function get_badge_type_details_hash(\r\n        uint256 _p_badge_type\r\n    ) public view returns (bytes memory badge_details_hash) {\r\n        // Do we have that badge?\r\n        require(\r\n            _badge_type_to_badge_details_hash[_p_badge_type].length > 0,\r\n            \"DonthaveDetails\"\r\n        );\r\n        badge_details_hash = _badge_type_to_badge_details_hash[_p_badge_type];\r\n    }\r\n\r\n    //// Give badge to customer, check if customer has specific badge\r\n    //// how many badges does customer hold,\r\n\r\n    function check_customer_badge(\r\n        uint256 _p_badge_type_to_check,\r\n        address customer\r\n    ) public view onlyConsole returns (bool _does_customer_have_badge) {\r\n        // Make sure customer is subscribed for this\r\n        require(\r\n            ILoyaltyConsole(campaign_owner).is_customer(customer),\r\n            \"NotSubbedForBadges\"\r\n        );\r\n\r\n        // Check if customer has this badge\r\n        uint256 total_held = _cust_address_to_total_held_badges[customer];\r\n        for (uint256 i = 0; i < total_held; ++i) {\r\n            // Remember: badge_type starts at 1\r\n            if (\r\n                _cust_add_to_held_badges_list[customer][i] ==\r\n                _p_badge_type_to_check\r\n            ) {\r\n                _does_customer_have_badge = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function award_badge(\r\n        address customer,\r\n        uint256 _p_badge_type\r\n    ) public onlyConsole {\r\n        // Is customer subscribed?\r\n        require(\r\n            ILoyaltyConsole(campaign_owner).is_customer(customer),\r\n            \"NotSubbedForBadges\"\r\n        );\r\n        // Does customer already have this badge?\r\n        require(!check_customer_badge(_p_badge_type, customer), \"AlreadyHasIt\");\r\n        // award badge to customer\r\n        _cust_add_to_held_badges_list[customer].push(_p_badge_type);\r\n        _cust_address_to_total_held_badges[customer] += 1;\r\n        // total circulating badges increased\r\n        total_badges_circulating += 1;\r\n    }\r\n\r\n    function total_customer_held_badges(\r\n        address customer\r\n    ) public view onlyConsole returns (uint256 _p_total_held) {\r\n        // Make sure customer is subscribed for this\r\n        require(\r\n            ILoyaltyConsole(campaign_owner).is_customer(customer),\r\n            \"NotSubbedForBadges\"\r\n        );\r\n        // Get total badges held by given customer\r\n        _p_total_held = _cust_address_to_total_held_badges[customer];\r\n    }\r\n}\r\n"},"interfaces/ILoyaltyConsole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// For BadgeFactory to use\r\ninterface ILoyaltyConsole {\r\n    function set_campaign_deployer(address) external;\r\n\r\n    function is_customer(address customer) external view returns (bool);\r\n}\r\n"},"CampaignBase.sol":{"content":"// SPDX-License-Identifier: SolDev-HP\r\npragma solidity 0.8.20;\r\nimport \"./interfaces/ICampaignBase.sol\";\r\nimport \"./interfaces/ILoyaltyConsole.sol\";\r\n\r\n// Other validations can be added such as _Campaign_details check before add\r\n// Address check before add - parameter in set_campaign_owner\r\n// Created at has no use for now, but I have plans.\r\n\r\ncontract CampaignBase is ICampaignBase {\r\n    // ------- State vars\r\n    // We need an owner and details-hash - common for all\r\n    address public campaign_owner;\r\n    bytes public campaign_details_hash;\r\n    uint public campaign_create_at;\r\n\r\n    event CampaignCreated(address _campaign_address);\r\n\r\n    constructor() {\r\n        // Not too serious use for now, if so, change block.timestamp to something else\r\n        campaign_create_at = block.timestamp;\r\n    }\r\n\r\n    // ------- Modifiers\r\n    modifier onlyConsole() {\r\n        require(msg.sender == campaign_owner, \"OnlyOwnerConsole\");\r\n        _;\r\n    }\r\n\r\n    function set_campaign_details(\r\n        bytes memory _campaign_details\r\n    ) external onlyConsole {\r\n        // Make sure only console can call - explain why @todo\r\n        // campaign_details_hash - contains CampaignData struct hash\r\n        campaign_details_hash = _campaign_details;\r\n    }\r\n\r\n    function set_campaign_owner(address _campaign_owner) external {\r\n        // I'll move to rolebased systems that are already established -\r\n        // like openzeppelin or solmate, once I make sure all campaign child contract -\r\n        // and their deployment sizes are within bounds after adding all -\r\n        // required functionalities to them. So till then, -\r\n        // we use a function that can - only once\r\n        require(campaign_owner == address(0x0), \"ShouldBeEmpty\");\r\n        campaign_owner = _campaign_owner;\r\n        emit CampaignCreated(address(this));\r\n    }\r\n\r\n    // Gets overridden by child campaign,\r\n    // that sets their own campaign_type return\r\n    function get_campaign_type_and_details()\r\n        public\r\n        view\r\n        virtual\r\n        returns (bytes memory campaign_hash, bytes memory campaign_type)\r\n    {\r\n        campaign_hash = campaign_details_hash;\r\n        campaign_type = \"Home\";\r\n    }\r\n}\r\n"},"interfaces/ICampaignBase.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// Campaign should have some basic functionalities\r\n// set_campaign_details_hash(bytes hash) -> none - possibly to update campaign details data with new hash\r\n// get_campaign_details_hash() -> bytes hash - for UI, simple hash can be translated into CampaignDetails struct with value\r\n// subscribe_customer(bytes cust_data_hash) -> none - subscribe customer with given customer data\r\n// get_number_of_subscribers() -> int - total number of subscribers in the campaign\r\n// function set_campaign_owner(address) external; - as we are using currently\r\n\r\n// update: 14/04\r\n// branch: feature_campaign_struct\r\n// Changes in ICampaignBased (named from ICampaign) as I will now consider this a base contract\r\n// Base campaign should be able to do following things\r\n//  Create a new campaign   (so it tracks total_campaign, )\r\n//  set campaign status (active, inactive, paused, discontinued, and more)\r\n//  Emit some basic events\r\n// Contains total_campaigns_count\r\n// Contains _console_that_owns_this_campaign address\r\n// Contains campaign_details_hash - and related functions\r\n// So naturally related modifiers will switch to here instead of child campaigns\r\n\r\ninterface ICampaignBase {\r\n    // Set campaign owner, campaign owner would be loyaltyconsole always\r\n    // but this happens inside campaign cloning and setup process\r\n    function set_campaign_owner(address) external;\r\n\r\n    // Campaign details comes in as an ipfs hash\r\n    function set_campaign_details(bytes memory) external;\r\n}\r\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}
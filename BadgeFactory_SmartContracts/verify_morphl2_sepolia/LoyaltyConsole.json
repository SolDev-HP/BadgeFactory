{"language":"Solidity","sources":{"LoyaltyConsole.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"./interfaces/IDeployer.sol\";\r\nimport \"./interfaces/ICampaignBase.sol\";\r\nimport \"./interfaces/IRewardPoints.sol\";\r\n\r\nimport \"./interfaces/IBadges.sol\";\r\n\r\n// import \"./interfaces/ITickets.sol\";\r\n// import \"./interfaces/ICodes.sol\";\r\n\r\n// Campaign types are:\r\n// 1 - Reward Points\r\n// 2 - Badges\r\n// 3 - Tickets\r\n// 4 - Codes\r\ncontract LoyaltyConsole {\r\n    // Total campaigns deployed vs total running\r\n    // Useful for UI interactions\r\n    // Keeping them all public can be useful in UI/UX\r\n    // These can be moved to private or offchain, we can keep track of each with event emitted\r\n    // @todo check if it actually saves gas and storage space\r\n    uint256 public total_campaigns;\r\n    // Only total, @todo add way to check support for given campaign type\r\n    uint256 public total_supported_campaigns;\r\n    // Home Address\r\n    address private _factory;\r\n    address private _campaigns_deployer;\r\n    uint256 private _total_customers;\r\n\r\n    // Role mapper\r\n    // @todo: verify msg.sender vs tx.origin\r\n    mapping(address => bool) public _is_address_Entity;\r\n    // This would change once we add Customer_data_hash, for now it'll work\r\n    mapping(address => bool) public _is_address_Customer;\r\n    // Supported campaigns - and where their clones are (Address)\r\n    mapping(address => bool) public is_address_Campaign;\r\n    enum Campaign_Types {\r\n        UNDEFINED, //0\r\n        REWARD_POINTS, //1\r\n        BADGES, //2\r\n        TICKETS, //3\r\n        CODES //4\r\n    }\r\n    Campaign_Types camp_type_choice;\r\n    mapping(uint256 => uint256) public campaign_type_to_deploy_count;\r\n    mapping(uint256 => address) private _campaign_type_to_implementation;\r\n\r\n    // LoyaltyConsole:\r\n    // Entity: deploy new campaigns, register new users, modify campaigns, remove campaigns\r\n    // Customer: participate or register with entity\r\n\r\n    // Entity can deploy same campaign multiple times\r\n    // record all deployments to keep track within this console\r\n    mapping(uint256 => address[]) public _campaign_type_to_list_of_deployed;\r\n\r\n    // Add customer subscription here, campaign interactions happen from\r\n    // console (for now) anyway\r\n    // This will later change to id => cust_data_hash\r\n    mapping(uint256 => address) private _cust_id_to_cust_address;\r\n\r\n    // ------------- Constructor\r\n    // Deploy with list of deployable + supported campaigns for this console\r\n    // i.e. customizable console\r\n    constructor(\r\n        address factory_address,\r\n        uint256[] memory supported_types,\r\n        address[] memory types_implementations\r\n    ) {\r\n        // Whoever originated the tx, not the creation happened by badgefactory\r\n        // because msg.sender will be badgefactory always\r\n        _factory = factory_address;\r\n        require(_factory == msg.sender, \"OnlyFactory!\"); // Interesting check, need to see if it works\r\n        // Msg.sender here will always be factory\r\n        // tx.origin should be business/brand that is interacting with BadgeFactory.sol\r\n        _is_address_Entity[tx.origin] = true;\r\n        for (uint256 i = 0; i < supported_types.length; i++) {\r\n            _campaign_type_to_implementation[\r\n                supported_types[i]\r\n            ] = types_implementations[i];\r\n            total_supported_campaigns += 1;\r\n        }\r\n    }\r\n\r\n    // ------------- Modifiers\r\n    // Next refactor: move to openzeppelin role management maybe?\r\n    // Initiators should be these roles\r\n    modifier roleEntity() {\r\n        require(_is_address_Entity[tx.origin], \"EntityOnly\");\r\n        _;\r\n    }\r\n    modifier roleCustomer() {\r\n        require(_is_address_Customer[tx.origin], \"CustOnly\");\r\n        _;\r\n    }\r\n    // Updater should be this role\r\n    modifier roleFactory() {\r\n        require(_factory == msg.sender, \"FactoryOnly!\");\r\n        _;\r\n    }\r\n    // And campaign backcalling to validate customer?\r\n    // One place I can think of is where we call onlySelf() with custoemr-\r\n    // address. So we callback to validate that address, and only child-\r\n    // campaigns can do that\r\n    modifier roleCampaign() {\r\n        require(is_address_Campaign[msg.sender], \"CampaignOnly!\");\r\n        _;\r\n    }\r\n\r\n    // -------------- External functions\r\n    function set_campaign_deployer(\r\n        address _deployer_addr\r\n    ) external roleFactory {\r\n        _campaigns_deployer = _deployer_addr;\r\n    }\r\n\r\n    // Subscribe customer for loyalty campaigns, this could easily\r\n    // allow console to deploy new campaigns considering existing subscribers\r\n    // and not subscribe everyone for every campaign deployed\r\n    // For now Entity manually subscribes customer with their customer_data (wallet address for now)\r\n    function subscribe_to_loyalty_system(\r\n        address customer_data\r\n    ) public roleEntity {\r\n        require(!_is_address_Customer[customer_data], \"AlreadySubbed\");\r\n        // cust_id is what total_customer is right now, so first cust starts at 0\r\n        _cust_id_to_cust_address[_total_customers] = customer_data;\r\n        // total customers have increased\r\n        _total_customers += 1;\r\n        // customer is now subscribed to use the loyalty system\r\n        _is_address_Customer[customer_data] = true;\r\n    }\r\n\r\n    // And later unsubscribe_from_loyalty_system()\r\n\r\n    // Check from campaign if current customer\r\n    function is_customer(\r\n        address customer\r\n    ) external view roleCampaign returns (bool) {\r\n        return _is_address_Customer[customer];\r\n    }\r\n\r\n    // Deploying campaigns through console\r\n    // I know it wont return anything, but currently declared\r\n    // return var is reused within the function, so I'm keeping it until next Refactor comes @todo\r\n\r\n    // pCampaign_details_hash[0] is always CampaignData struct\r\n    // pCampaign_details_hash[1...N] are badges/tickets/coupons depending on campaign type\r\n    function start_campaign(\r\n        uint256 p_campaign_type,\r\n        bytes[] memory p_campaign_details_hash\r\n    ) public roleEntity returns (address _campaign_addr) {\r\n        // Verify that we have atleast 1 hash with details\r\n        // dont matter if it's 0x0 but there has to be atleast one\r\n        require(p_campaign_details_hash.length > 0, \"Atleast1Hash\");\r\n        // Assumed\r\n        require((0 < p_campaign_type) && (p_campaign_type < 5), \"1to4Only!\");\r\n        // Deployer is needed but deployer doesn't do anything for now. if you run into this,\r\n        // unittests are failing\r\n        require(address(_campaigns_deployer) != address(0), \"DeployerNeeded!\");\r\n\r\n        // Do we have requested campaign implementation available?\r\n        require(\r\n            _campaign_type_to_implementation[p_campaign_type] != address(0x0),\r\n            \"CampNotSupported\"\r\n        );\r\n\r\n        // Clone required campaign type\r\n        _campaign_addr = Clones.clone(\r\n            _campaign_type_to_implementation[p_campaign_type]\r\n        );\r\n        // Validate campaign deployment\r\n        require(address(_campaign_addr) != address(0), \"FailedCampDeploy!\");\r\n        // Set self as campaign owner, campaign control is on console\r\n        ICampaignBase(_campaign_addr).set_campaign_owner(address(this));\r\n        //// one hash sets by default, this sets Campaignbase details_hash\r\n        ICampaignBase(_campaign_addr).set_campaign_details(\r\n            p_campaign_details_hash[0]\r\n        );\r\n        if (p_campaign_details_hash.length > 1) {\r\n            // we verified that hashs array contain atleast one element\r\n            // Set total_badges_types first\r\n            // Not checking campaign_type for now as the only other type is badges\r\n            // tickets and codes are still in skeleton stage, so this will change when\r\n            // those are implemented like rewardpoints and badges campaigns contract : @todo\r\n            IBadges(_campaign_addr).set_total_badges_types(\r\n                p_campaign_details_hash.length - 1 // As first hash is parent hash - CampaignData\r\n                // Second onwards are badges/or any other that require multiple file hashes\r\n            );\r\n            // Then setup all badges types with their corresponding details_hash in the list\r\n            IBadges(_campaign_addr).set_all_badges_details_hashes(\r\n                p_campaign_details_hash\r\n            );\r\n        }\r\n        // _campaign_id for RewardPoints(1), Badges(2), Tickets(3), Codes(4)\r\n        // Probably needs more data along with each type, changes as we go\r\n        // Set campaign details hash, update related campaign counter\r\n        campaign_type_to_deploy_count[p_campaign_type] += 1;\r\n        // Increase total\r\n        total_campaigns += 1;\r\n        // Add to list of deployed\r\n        _campaign_type_to_list_of_deployed[p_campaign_type].push(\r\n            address(_campaign_addr)\r\n        );\r\n        // the address is now a campaign\r\n        is_address_Campaign[_campaign_addr] = true;\r\n    }\r\n\r\n    // Coming from BadgeFactory.sol - keep if needed\r\n    // Length of Campaigns returned from the mapping can be used to check total\r\n    // BadgeFactory Users\r\n    // struct Campaigns {\r\n    //     uint256 _campaign_id;\r\n    //     address _campaign_deployed_at;\r\n    //     // A way to identify campaign type (points, badges, tickets etc)\r\n    // }\r\n    // mapping(address => Campaigns[]) public campaign_deployers;\r\n\r\n    // Manually end any running campaign\r\n    // Implement function end_campaign(campaign_id) - set active false\r\n    // Implement auto end_campaign() - based on timestamp end_campaign - should update to active false (how?)\r\n\r\n    function interact_rewardpoints(\r\n        address customer,\r\n        uint points,\r\n        uint256 campaign_type,\r\n        bool _is_allocation\r\n    ) public roleEntity {\r\n        // Fidn last deployed reward points campaign\r\n        // Make sure we have atleast 1 reward points campaign deployed\r\n        require(\r\n            _campaign_type_to_list_of_deployed[campaign_type][0] !=\r\n                address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n        // Get the latest deployed rewardpoints campaign\r\n        address campAddr = _campaign_type_to_list_of_deployed[campaign_type][\r\n            campaign_type_to_deploy_count[campaign_type] - 1\r\n        ];\r\n        // If no points interaction (points are 0), subscribe\r\n        if (points == 0) {\r\n            // If we add a custoemr into reward points, add into loyaltyconsole\r\n            // Subscribe to loyalty system as well, if not already\r\n            if (!_is_address_Customer[customer]) {\r\n                subscribe_to_loyalty_system(customer);\r\n                // This will change in later versions\r\n                _is_address_Customer[customer] = true;\r\n            }\r\n            // This way, we allow customer to choose if they'd want to\r\n            // participate in any given loyalty campaign. By default, they\r\n            // are included, but they can interct with campaign and unsubscribe\r\n            IRewardPoints(campAddr).subscribe_customer(customer);\r\n        } else {\r\n            // if points are nonzero, it's an reward/redeem - reward_points\r\n            if (_is_allocation) {\r\n                IRewardPoints(campAddr).reward_points(customer, points);\r\n            } else {\r\n                IRewardPoints(campAddr).redeem_points(customer, points);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Now we have following functionality in badges\r\n\r\n    function interact_badges(\r\n        address customer,\r\n        uint256 _p_action,\r\n        uint256 _p_awarded_badge_type, // can be 0 for other actions\r\n        bytes[] memory _badges_hashes // along with updated campaigndetails struct too at 0 index\r\n    ) public roleEntity {\r\n        // So for badges, we can have following interactions:\r\n        // Subscribe(1): customer subscribe to deployed badges campaign\r\n        // Set_Total_types_of_Badges(2): set total types of badges(uint256 x)\r\n        // set_all_badges_details(3):\r\n        // award_badge_to_customer(4):\r\n        // Entity creates badges campaign\r\n        // Is customer registered\r\n        if (_p_action == 1) {\r\n            subscribe_to_loyalty_system(customer);\r\n            return;\r\n        }\r\n        // Make sure we have the campaign deployed\r\n        // uint256 campaign_type = uint(Campaign_Types.BADGES);\r\n        require(\r\n            _campaign_type_to_list_of_deployed[2][\r\n                campaign_type_to_deploy_count[2] - 1\r\n            ] != address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n\r\n        // Get the campaign deployment address\r\n        // Get the latest deployed rewardpoints campaign\r\n        address campAddr = _campaign_type_to_list_of_deployed[2][\r\n            // make sure to grab the latest badges deployed\r\n            campaign_type_to_deploy_count[2] - 1\r\n        ];\r\n\r\n        if (_p_action == 3) {\r\n            IBadges(campAddr).set_all_badges_details_hashes(_badges_hashes);\r\n            return;\r\n        }\r\n\r\n        if (_p_action == 4) {\r\n            require(_p_awarded_badge_type != 0, \"TypeStartsAt1\");\r\n            IBadges(campAddr).award_badge(customer, _p_awarded_badge_type);\r\n            return;\r\n        }\r\n    }\r\n\r\n    // Badges view related functionalities can be grouped here\r\n    // For now we have total_held_by_customer\r\n    function view_badges(\r\n        address customer\r\n    ) public view roleEntity returns (uint256) {\r\n        // need to make sure campaign(badges) is deployed\r\n        uint256 campaign_type = uint(Campaign_Types.BADGES);\r\n        require(\r\n            _campaign_type_to_list_of_deployed[campaign_type][0] !=\r\n                address(0x0),\r\n            \"NoCampaign\"\r\n        );\r\n\r\n        // Get campaign address\r\n        address campAddr = _campaign_type_to_list_of_deployed[campaign_type][\r\n            // make sure to grab the latest badges deployed\r\n            campaign_type_to_deploy_count[campaign_type] - 1\r\n        ];\r\n\r\n        // This will change later, right now I'm concerned with total held\r\n        return IBadges(campAddr).total_customer_held_badges(customer);\r\n    }\r\n\r\n    function interact_tickets() public roleEntity {}\r\n\r\n    function interact_codes() public roleEntity {}\r\n}\r\n"},"interfaces/IBadges.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IBadges {\r\n    // Customer subscription\r\n    function subscribe_customer(address) external;\r\n\r\n    // function get owner\r\n    function campaign_owner() external returns (address);\r\n\r\n    // Badges specific functions\r\n    // set multiple badges details hashes\r\n    // These are implemented as consoleOnly() callable functions\r\n    function set_total_badges_types(uint256) external;\r\n\r\n    function set_all_badges_details_hashes(bytes[] memory) external;\r\n\r\n    function get_badge_type_details_hash(\r\n        uint256\r\n    ) external view returns (bytes memory);\r\n\r\n    // Badges interactions, award customer a badge, check if customer -\r\n    // has given badge, check total customer held badges\r\n    function award_badge(address, uint256) external;\r\n\r\n    function check_customer_badge(\r\n        uint256,\r\n        address\r\n    ) external view returns (bool);\r\n\r\n    function total_customer_held_badges(\r\n        address\r\n    ) external view returns (uint256);\r\n}\r\n"},"interfaces/IRewardPoints.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IRewardPoints {\r\n    // Customer subscription\r\n    function subscribe_customer(address) external;\r\n\r\n    // Reward Points Interactions\r\n    function reward_points(address, uint256) external;\r\n\r\n    function redeem_points(address, uint256) external;\r\n}\r\n"},"interfaces/ICampaignBase.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\n// Campaign should have some basic functionalities\r\n// set_campaign_details_hash(bytes hash) -> none - possibly to update campaign details data with new hash\r\n// get_campaign_details_hash() -> bytes hash - for UI, simple hash can be translated into CampaignDetails struct with value\r\n// subscribe_customer(bytes cust_data_hash) -> none - subscribe customer with given customer data\r\n// get_number_of_subscribers() -> int - total number of subscribers in the campaign\r\n// function set_campaign_owner(address) external; - as we are using currently\r\n\r\n// update: 14/04\r\n// branch: feature_campaign_struct\r\n// Changes in ICampaignBased (named from ICampaign) as I will now consider this a base contract\r\n// Base campaign should be able to do following things\r\n//  Create a new campaign   (so it tracks total_campaign, )\r\n//  set campaign status (active, inactive, paused, discontinued, and more)\r\n//  Emit some basic events\r\n// Contains total_campaigns_count\r\n// Contains _console_that_owns_this_campaign address\r\n// Contains campaign_details_hash - and related functions\r\n// So naturally related modifiers will switch to here instead of child campaigns\r\n\r\ninterface ICampaignBase {\r\n    // Set campaign owner, campaign owner would be loyaltyconsole always\r\n    // but this happens inside campaign cloning and setup process\r\n    function set_campaign_owner(address) external;\r\n\r\n    // Campaign details comes in as an ipfs hash\r\n    function set_campaign_details(bytes memory) external;\r\n}\r\n"},"interfaces/IDeployer.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\ninterface IDeployer {\r\n    // It has only one work, deploy any given deploycode data and return address\r\n    function deploy_campaign(bytes memory) external returns (address);\r\n\r\n    // factoryonly function\r\n    function change_accessor(address, bool) external returns (bool);\r\n}\r\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"}},"settings":{"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}